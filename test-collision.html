<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collision Detection Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .test-result {
            margin: 5px 0;
            padding: 5px 10px;
            border-radius: 3px;
        }
        .pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .summary {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
        canvas {
            border: 2px solid #333;
            margin: 10px 0;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Collision Detection Test Suite</h1>
        
        <div id="test-results"></div>
        
        <div class="test-section">
            <h3>Visual Test</h3>
            <canvas id="testCanvas" width="400" height="400"></canvas>
            <p>Visual representation of collision detection tests</p>
        </div>
        
        <div id="summary" class="summary"></div>
    </div>

    <!-- Load required classes -->
    <script src="js/Vector2D.js"></script>
    <script src="js/Hexagon.js"></script>
    <script src="js/Renderer.js"></script>
    <script src="test/verify-collision-detection.js"></script>

    <script>
        class CollisionTestSuite {
            constructor() {
                this.testCount = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                this.results = [];
            }
            
            assert(condition, message) {
                this.testCount++;
                if (condition) {
                    this.passedTests++;
                    this.results.push({ type: 'pass', message });
                } else {
                    this.failedTests++;
                    this.results.push({ type: 'fail', message });
                    throw new Error(`Assertion failed: ${message}`);
                }
            }
            
            assertApproxEqual(actual, expected, tolerance, message) {
                const diff = Math.abs(actual - expected);
                this.assert(diff < tolerance, `${message} (expected: ${expected}, actual: ${actual}, diff: ${diff.toFixed(6)})`);
            }
            
            testPointInsideDetection() {
                console.log('Testing Point Inside Detection...');
                
                const hexagon = new Hexagon(0, 0, 100);
                
                // Test center point
                const centerPoint = new Vector2D(0, 0);
                this.assert(hexagon.isPointInside(centerPoint), 'Center point should be inside hexagon');
                
                // Test points clearly outside
                const outsidePoints = [
                    new Vector2D(200, 0),
                    new Vector2D(0, 200),
                    new Vector2D(-200, 0),
                    new Vector2D(0, -200)
                ];
                
                outsidePoints.forEach((point, index) => {
                    this.assert(!hexagon.isPointInside(point), 
                        `Outside point ${index + 1} should not be inside`);
                });
                
                // Test points clearly inside
                const insidePoints = [
                    new Vector2D(50, 0),
                    new Vector2D(0, 50),
                    new Vector2D(-50, 0),
                    new Vector2D(0, -50)
                ];
                
                insidePoints.forEach((point, index) => {
                    this.assert(hexagon.isPointInside(point), 
                        `Inside point ${index + 1} should be inside`);
                });
            }
            
            testBallCollisionDetection() {
                console.log('Testing Ball Collision Detection...');
                
                const hexagon = new Hexagon(0, 0, 100);
                
                // Test 1: Ball clearly outside (no collision)
                const outsideBall = {
                    position: new Vector2D(200, 0),
                    radius: 10
                };
                const noCollision = hexagon.checkCollision(outsideBall);
                this.assert(noCollision === null, 'Ball far outside should not collide');
                
                // Test 2: Ball inside near edge (collision expected)
                const nearEdgeBall = {
                    position: new Vector2D(85, 0),
                    radius: 20
                };
                const edgeCollision = hexagon.checkCollision(nearEdgeBall);
                this.assert(edgeCollision !== null, 'Ball near edge should collide');
                this.assert(edgeCollision.penetration > 0, 'Collision should have positive penetration');
                
                // Test 3: Small ball at center (no collision)
                const centerBall = {
                    position: new Vector2D(0, 0),
                    radius: 10
                };
                const centerCollision = hexagon.checkCollision(centerBall);
                this.assert(centerCollision === null, 'Small ball at center should not collide');
                
                // Test 4: Large ball at center (collision with all edges)
                const largeBall = {
                    position: new Vector2D(0, 0),
                    radius: 120
                };
                const largeCollision = hexagon.checkCollision(largeBall);
                this.assert(largeCollision !== null, 'Large ball should collide with edges');
                this.assert(largeCollision.penetration > 0, 'Large ball should have penetration');
            }
            
            testCollisionNormalVectors() {
                console.log('Testing Collision Normal Vectors...');
                
                const hexagon = new Hexagon(0, 0, 100);
                
                // Test collision with right edge
                const rightBall = {
                    position: new Vector2D(95, 0),
                    radius: 10
                };
                const rightCollision = hexagon.checkCollision(rightBall);
                if (rightCollision) {
                    this.assert(rightCollision.normal.x > 0, 'Right edge collision normal should point right');
                    this.assertApproxEqual(rightCollision.normal.magnitude(), 1, 0.001, 
                        'Normal vector should be unit length');
                }
            }
            
            testDistanceToEdgeCalculation() {
                console.log('Testing Distance to Edge Calculation...');
                
                const hexagon = new Hexagon(0, 0, 100);
                
                // Test distance from point to horizontal line
                const point = new Vector2D(0, 0);
                const lineStart = new Vector2D(-50, 10);
                const lineEnd = new Vector2D(50, 10);
                
                const result = hexagon.getDistanceToEdge(point, lineStart, lineEnd);
                
                this.assertApproxEqual(result.distance, 10, 0.001, 'Distance to horizontal line should be 10');
                this.assertApproxEqual(result.normal.x, 0, 0.001, 'Normal X component should be 0');
                this.assertApproxEqual(result.normal.y, -1, 0.001, 'Normal Y component should be -1');
            }
            
            testCollisionWithRotation() {
                console.log('Testing Collision with Hexagon Rotation...');
                
                const hexagon = new Hexagon(0, 0, 100);
                
                const ball = {
                    position: new Vector2D(90, 0),
                    radius: 15
                };
                
                // Test collision at different rotation angles
                const rotationAngles = [0, Math.PI / 6, Math.PI / 3, Math.PI / 2];
                
                rotationAngles.forEach((angle, index) => {
                    hexagon.rotate(angle);
                    const collision = hexagon.checkCollision(ball);
                    
                    if (collision) {
                        this.assertApproxEqual(collision.normal.magnitude(), 1, 0.001, 
                            `Normal vector should be unit length at rotation ${index}`);
                    }
                });
            }
            
            testConsistencyAcrossAllEdges() {
                console.log('Testing Consistency Across All Edges...');
                
                const hexagon = new Hexagon(0, 0, 100);
                const ballRadius = 15;
                const testDistance = 80;
                
                // Test collision at 6 different angles
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3;
                    const ball = {
                        position: new Vector2D(
                            testDistance * Math.cos(angle),
                            testDistance * Math.sin(angle)
                        ),
                        radius: ballRadius
                    };
                    
                    const collision = hexagon.checkCollision(ball);
                    this.assert(collision !== null, `Ball should collide with edge ${i + 1}`);
                    this.assert(collision.penetration > 0, `Edge ${i + 1} collision should have penetration`);
                }
            }
            
            visualTest() {
                console.log('Running Visual Test...');
                
                const canvas = document.getElementById('testCanvas');
                const renderer = new Renderer(canvas);
                
                // Create hexagon at canvas center
                const hexagon = new Hexagon(200, 200, 80);
                
                // Create test balls
                const testBalls = [
                    { position: new Vector2D(150, 200), radius: 15, color: '#FF5722' }, // Should collide
                    { position: new Vector2D(200, 200), radius: 10, color: '#4CAF50' }, // Center, no collision
                    { position: new Vector2D(300, 200), radius: 20, color: '#2196F3' }, // Outside, no collision
                    { position: new Vector2D(200, 150), radius: 25, color: '#FF9800' }  // Should collide
                ];
                
                // Clear and draw
                renderer.clear();
                
                // Draw hexagon
                hexagon.render(renderer);
                
                // Draw balls and check collisions
                testBalls.forEach((ball, index) => {
                    const collision = hexagon.checkCollision(ball);
                    
                    // Change color based on collision
                    const ballColor = collision ? '#FF0000' : ball.color;
                    renderer.drawCircle(ball.position.x, ball.position.y, ball.radius, ballColor);
                    
                    // Draw collision normal if exists
                    if (collision) {
                        const normalEnd = ball.position.add(collision.normal.multiply(30));
                        renderer.ctx.beginPath();
                        renderer.ctx.moveTo(ball.position.x, ball.position.y);
                        renderer.ctx.lineTo(normalEnd.x, normalEnd.y);
                        renderer.ctx.strokeStyle = '#00FF00';
                        renderer.ctx.lineWidth = 2;
                        renderer.ctx.stroke();
                    }
                });
                
                this.assert(true, 'Visual test completed successfully');
            }
            
            runAllTests() {
                console.log('Starting Collision Detection Test Suite...');
                
                try {
                    this.testPointInsideDetection();
                    this.testBallCollisionDetection();
                    this.testCollisionNormalVectors();
                    this.testDistanceToEdgeCalculation();
                    this.testCollisionWithRotation();
                    this.testConsistencyAcrossAllEdges();
                    this.visualTest();
                    
                    this.displayResults();
                    
                } catch (error) {
                    console.error('Test failed:', error.message);
                    this.displayResults();
                }
            }
            
            displayResults() {
                const resultsDiv = document.getElementById('test-results');
                const summaryDiv = document.getElementById('summary');
                
                // Display individual test results
                this.results.forEach(result => {
                    const div = document.createElement('div');
                    div.className = `test-result ${result.type}`;
                    div.textContent = `${result.type === 'pass' ? '‚úì' : '‚ùå'} ${result.message}`;
                    resultsDiv.appendChild(div);
                });
                
                // Display summary
                const successRate = ((this.passedTests / this.testCount) * 100).toFixed(1);
                summaryDiv.innerHTML = `
                    <strong>Test Results:</strong> ${this.passedTests}/${this.testCount} passed (${successRate}%)<br>
                    ${this.failedTests === 0 ? 'üéâ All collision detection tests passed!' : `‚ùå ${this.failedTests} tests failed`}
                `;
                
                console.log(`Test Results: ${this.passedTests}/${this.testCount} passed`);
            }
        }
        
        // Run tests when page loads
        window.addEventListener('load', () => {
            const testSuite = new CollisionTestSuite();
            testSuite.runAllTests();
        });
    </script>
</body>
</html>